<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legal Context Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #000; }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        #controls-panel {
            position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.98);
            color: #333; padding: 25px; border-radius: 16px; width: 420px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2); backdrop-filter: blur(12px);
            border: 1px solid rgba(0,0,0,0.1);
        }
        #controls-panel h2 { text-align: center; margin: 0 0 20px 0; color: #111; font-size: 1.8em; }
        .control-group { margin-top: 25px; }
        .control-group h3 {
            margin: 0 0 12px 0; font-size: 1.2em; border-bottom: 1px solid #eee;
            padding-bottom: 10px; color: #444; font-weight: 600;
        }
        .button-grid { display: flex; flex-wrap: wrap; gap: 10px; }
        .control-group button {
            background: #f0f0f0; border: 1px solid #ccc; padding: 10px 16px;
            border-radius: 8px; cursor: pointer; transition: all 0.2s; font-size: 15px;
        }
        .control-group button:hover { background: #e0e0e0; border-color: #bbb; }
        .control-group button.active {
            background: var(--accent-color, #D97356); color: white;
            border-color: var(--accent-color-dark, #c85a3f);
            font-weight: bold; transform: scale(1.05);
        }
        #info-panel { margin-top: 30px; padding-top: 20px; border-top: 2px solid #ddd; }
        #privilege-status {
            font-size: 1.4em; font-weight: bold; text-align: center;
            padding: 14px; border-radius: 10px; margin-bottom: 15px;
        }
        #privilege-details { font-size: 1.05em; line-height: 1.6; color: #555; }
        .flag-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb;}
        .flag-danger { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;}
        .flag-neutral { background-color: #e2e3e5; color: #383d41; border: 1px solid #d6d8db;}
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="controls-panel">
        <h2 id="title"></h2>
        <div class="control-group">
            <h3>1. Select Alice's Role (The Actor)</h3>
            <div id="role-toggles" class="button-grid"></div>
        </div>
        <div class="control-group">
            <h3>2. Select the Interaction (The Action)</h3>
            <div id="action-toggles" class="button-grid"></div>
        </div>
        <div id="info-panel">
            <div id="privilege-status"></div>
            <p id="privilege-details"></p>
        </div>
    </div>
    
    <script src="config.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // === GLOBAL VARIABLES ===
        let scene, camera, renderer;
        let alice, bob, actionVisual;

        // === STATE MANAGEMENT ===
        let currentState = {
            role: CONFIG.scenario.roles[0].id,
            action: CONFIG.scenario.actions[0].id
        };

        // === INITIALIZATION ===
        function init() {
            // Basic Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.theme.backgroundColor);
            scene.fog = new THREE.Fog(CONFIG.theme.backgroundColor, 15, 40);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2.5, 10);
            camera.lookAt(0, 1.5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio); // <<< VISUAL FIX: For sharp rendering on Retina/Hi-DPI screens
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 50),
                new THREE.MeshStandardMaterial({ color: CONFIG.theme.floorColor, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Create Scene Objects
            alice = createCharacter('Alice', CONFIG.scenario.actors.alice);
            scene.add(alice);
            bob = createCharacter('Bob', CONFIG.scenario.actors.bob);
            scene.add(bob);
            actionVisual = createActionVisual();
            scene.add(actionVisual);

            // Initialize UI
            document.getElementById('title').textContent = CONFIG.general.title;
            initializeControls();

            // Initial Update
            updateScene();
            
            // Start Animation Loop
            animate();
        }

        // === SCENE OBJECT CREATION ===
        function createCharacter(name, config) {
            const group = new THREE.Group();
            const torsoMaterial = new THREE.MeshStandardMaterial({ color: name === 'Alice' ? 0x9b59b6 : 0x3498db, roughness: 0.7 });
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 1.2, 16), torsoMaterial);
            torso.position.y = 0.6;
            torso.castShadow = true;
            group.add(torso);
            
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffe0bd, roughness: 0.6 });
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 32, 32), headMaterial);
            head.position.y = 1.55;
            head.castShadow = true;
            group.add(head);

            // <<< VISUAL FIX: Increased vertical separation and tuned font properties
            group.userData.nameLabel = createTextLabel(name, 'bold 36px Arial', '#000000');
            group.userData.nameLabel.position.y = 2.4;
            group.add(group.userData.nameLabel);

            group.userData.roleLabel = createTextLabel('', '28px Arial', '#333333');
            group.userData.roleLabel.position.y = 2.0;
            group.add(group.userData.roleLabel);
            
            group.position.set(config.position.x, 0, config.position.z);
            return group;
        }

        function createActionVisual() {
            const group = new THREE.Group();
            
            const backgroundMaterial = new THREE.MeshBasicMaterial({ color: CONFIG.theme.accentColor });
            const backgroundMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), backgroundMaterial);
            group.add(backgroundMesh);
            group.userData.background = backgroundMesh;

            group.userData.label = createTextLabel('', 'bold 32px Arial', '#FFFFFF');
            group.userData.label.position.z = 0.01;
            group.add(group.userData.label);
            
            // <<< VISUAL FIX: Positioned above characters to prevent overlap
            group.position.set(0, 3.0, 0); 
            return group;
        }
        
        // <<< VISUAL FIX: Revised text label factory for higher quality rendering
        function createTextLabel(text, font, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = font;
            
            const textMetrics = context.measureText(text);
            const textWidth = textMetrics.width;

            // Use power-of-two dimensions for better performance, with padding
            canvas.width = THREE.MathUtils.ceilPowerOfTwo(textWidth + 64);
            canvas.height = 128; // Fixed high-res height
            
            // Re-apply font after canvas resize, as it gets cleared
            context.font = font;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter; // Smooth scaling
            texture.needsUpdate = true;

            const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
            // Scale sprite based on canvas aspect ratio to maintain proportions
            label.scale.set(canvas.width / canvas.height * 2.5, 2.5, 1);
            return label;
        }

        // === UI & STATE LOGIC ===
        function initializeControls() {
            const roleContainer = document.getElementById('role-toggles');
            CONFIG.scenario.roles.forEach(role => {
                const btn = document.createElement('button');
                btn.textContent = role.name;
                btn.dataset.id = role.id;
                btn.onclick = () => { currentState.role = role.id; updateScene(); };
                roleContainer.appendChild(btn);
            });

            const actionContainer = document.getElementById('action-toggles');
            CONFIG.scenario.actions.forEach(action => {
                const btn = document.createElement('button');
                btn.textContent = action.name;
                btn.dataset.id = action.id;
                btn.onclick = () => { currentState.action = action.id; updateScene(); };
                actionContainer.appendChild(btn);
            });
        }
        
        function updateScene() {
            const currentRole = CONFIG.scenario.roles.find(r => r.id === currentState.role);
            const currentAction = CONFIG.scenario.actions.find(a => a.id === currentState.action);

            // Update Labels
            updateTextLabel(alice.userData.roleLabel, `(${currentRole.name})`);
            updateTextLabel(bob.userData.roleLabel, `(${currentRole.bobRole})`);
            updateTextLabel(actionVisual.userData.label, currentAction.name, true);
            
            // Update Active Buttons
            document.querySelectorAll('#role-toggles button').forEach(b => b.classList.toggle('active', b.dataset.id === currentState.role));
            document.querySelectorAll('#action-toggles button').forEach(b => b.classList.toggle('active', b.dataset.id === currentState.action));

            // Use the implications map from config.js
            const implicationKey = `${currentState.role}-${currentState.action}`;
            const result = CONFIG.scenario.implications[implicationKey] || CONFIG.scenario.implications['default'];
            
            const statusEl = document.getElementById('privilege-status');
            const detailsEl = document.getElementById('privilege-details');
            
            statusEl.textContent = result.privilege.text;
            detailsEl.textContent = result.details;

            if (result.privilege.applies === true) {
                statusEl.className = 'flag-success';
            } else if (result.privilege.applies === false) {
                statusEl.className = 'flag-danger';
            } else {
                statusEl.className = 'flag-neutral';
            }
        }
        
        function updateTextLabel(labelSprite, newText, isAction = false) {
            const canvas = labelSprite.material.map.image;
            const context = canvas.getContext('2d');
            const font = context.font;

            // Recalculate width for the new text
            const textWidth = context.measureText(newText).width;
            const newCanvasWidth = THREE.MathUtils.ceilPowerOfTwo(textWidth + 64);
            
            if (canvas.width !== newCanvasWidth) {
                canvas.width = newCanvasWidth;
            }

            context.clearRect(0, 0, canvas.width, canvas.height);
            context.font = font;
            context.fillStyle = isAction ? '#FFFFFF' : labelSprite.material.color.getStyle(); // Action text is always white
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(newText, canvas.width / 2, canvas.height / 2);
            labelSprite.material.map.needsUpdate = true;
            
            const newScale = (canvas.width / canvas.height) * 2.5;
            labelSprite.scale.set(newScale, 2.5, 1);
            
            if (isAction) {
                const backgroundSprite = labelSprite.parent.userData.background;
                backgroundSprite.scale.x = newScale * 1.1; // Make background slightly wider
                backgroundSprite.scale.y = 2.8;
            }
        }

        // === ANIMATION LOOP ===
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // === START ===
        init();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>